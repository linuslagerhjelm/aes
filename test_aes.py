from unittest import TestCase
import AES

inp = b'linuslagerhjelm1'
key = b'secretkeybytes19'


class TestAES(TestCase):
    def test_sunny_day_encryption(self):
        expected = 'd17Mm4oZ1yfuIMPds6m0eDLYTQgauSnIy0t/ENKay7A='
        actual = AES.encrypt(inp, key)
        self.assertEqual(expected, actual)

    def test_nibbles(self):
        expected = (7, 3)
        actual = AES._nibbles(115)
        self.assertEqual(expected, actual)

    def test_sub_bytes(self):
        state = [
            [0x00, 0x3C, 0x6E, 0x47],
            [0x1F, 0x4E, 0x22, 0x74],
            [0x0E, 0x08, 0x1B, 0x31],
            [0x54, 0x59, 0x0B, 0x1A]
        ]
        expected = [
            [0x63, 0xEB, 0x9F, 0xA0],
            [0xC0, 0x2F, 0x93, 0x92],
            [0xAB, 0x30, 0xAF, 0xC7],
            [0x20, 0xCB, 0x2B, 0xA2],
        ]
        actual = AES._sub_bytes(state)
        self.assertEqual(expected, actual)

    def test_shift_rows(self):
        state = [
            [0x63, 0xEB, 0x9F, 0xA0],
            [0xC0, 0x2F, 0x93, 0x92],
            [0xAB, 0x30, 0xAF, 0xC7],
            [0x20, 0xCB, 0x2B, 0xA2],
        ]
        expected = [
            [0x63, 0xEB, 0x9F, 0xA0],
            [0x2F, 0x93, 0x92, 0xC0],
            [0xAF, 0xC7, 0xAB, 0x30],
            [0xA2, 0x20, 0xCB, 0x2B],
        ]
        actual = AES._shift_rows(state)
        self.assertEqual(expected, actual)

    def test_mix_column(self):
        state = [
            [0x63, 0xEB, 0x9F, 0xA0],
            [0x2F, 0x93, 0x92, 0xC0],
            [0xAF, 0xC7, 0xAB, 0x30],
            [0xA2, 0x20, 0xCB, 0x2B],
        ]
        expected = [
            [0xBA, 0x84, 0xE8, 0x1B],
            [0x75, 0xA4, 0x8D, 0x40],
            [0xF4, 0x8D, 0x06, 0x7D],
            [0x7A, 0x32, 0x0E, 0x5D],
        ]
        actual = AES._mix_columns(state)
        self.assertEqual(expected, actual)

    def test_add_roundkey(self):
        state = [
            [0xBA, 0x84, 0xE8, 0x1B],
            [0x75, 0xA4, 0x8D, 0x40],
            [0xF4, 0x8D, 0x06, 0x7D],
            [0x7A, 0x32, 0x0E, 0x5D],
        ]
        round_key = [
            [0xE2, 0x91, 0xB1, 0xD6],
            [0x32, 0x12, 0x59, 0x79],
            [0xFC, 0x91, 0xE4, 0xA2],
            [0xF1, 0x88, 0xE6, 0x93],
        ]

        expected = [
            [0x58, 0x15, 0x59, 0xCD],
            [0x47, 0xB6, 0xD4, 0x39],
            [0x08, 0x1C, 0xE2, 0xDF],
            [0x8B, 0xBA, 0xE8, 0xCE],
        ]
        actual = AES._add_roundkey(state, round_key)
        self.assertEqual(expected, actual)

    def test_perform_round(self):
        block = [
            [0x00, 0x3C, 0x6E, 0x47],
            [0x1F, 0x4E, 0x22, 0x74],
            [0x0E, 0x08, 0x1B, 0x31],
            [0x54, 0x59, 0x0B, 0x1A]
        ]
        round_key = [
            [0xE2, 0x91, 0xB1, 0xD6],
            [0x32, 0x12, 0x59, 0x79],
            [0xFC, 0x91, 0xE4, 0xA2],
            [0xF1, 0x88, 0xE6, 0x93],
        ]
        expected = [
            [0x58, 0x47, 0x08, 0x8B],
            [0x15, 0xB6, 0x1C, 0xBA],
            [0x59, 0xD4, 0xE2, 0xE8],
            [0xCD, 0x39, 0xDF, 0xCE],
        ]
        actual = AES._round(block, round_key)
        self.assertEqual(expected, actual)
